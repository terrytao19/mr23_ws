// Generated by gencpp from file novatel_oem7_msgs/INSSTDEV.msg
// DO NOT EDIT!


#ifndef NOVATEL_OEM7_MSGS_MESSAGE_INSSTDEV_H
#define NOVATEL_OEM7_MSGS_MESSAGE_INSSTDEV_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>
#include <novatel_oem7_msgs/Oem7Header.h>
#include <novatel_oem7_msgs/INSExtendedSolutionStatus.h>

namespace novatel_oem7_msgs
{
template <class ContainerAllocator>
struct INSSTDEV_
{
  typedef INSSTDEV_<ContainerAllocator> Type;

  INSSTDEV_()
    : header()
    , nov_header()
    , latitude_stdev(0.0)
    , longitude_stdev(0.0)
    , height_stdev(0.0)
    , north_velocity_stdev(0.0)
    , east_velocity_stdev(0.0)
    , up_velocity_stdev(0.0)
    , roll_stdev(0.0)
    , pitch_stdev(0.0)
    , azimuth_stdev(0.0)
    , ext_sol_status()
    , time_since_last_update(0)
    , reserved1(0)
    , reserved2(0)
    , reserved3(0)  {
    }
  INSSTDEV_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , nov_header(_alloc)
    , latitude_stdev(0.0)
    , longitude_stdev(0.0)
    , height_stdev(0.0)
    , north_velocity_stdev(0.0)
    , east_velocity_stdev(0.0)
    , up_velocity_stdev(0.0)
    , roll_stdev(0.0)
    , pitch_stdev(0.0)
    , azimuth_stdev(0.0)
    , ext_sol_status(_alloc)
    , time_since_last_update(0)
    , reserved1(0)
    , reserved2(0)
    , reserved3(0)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef  ::novatel_oem7_msgs::Oem7Header_<ContainerAllocator>  _nov_header_type;
  _nov_header_type nov_header;

   typedef float _latitude_stdev_type;
  _latitude_stdev_type latitude_stdev;

   typedef float _longitude_stdev_type;
  _longitude_stdev_type longitude_stdev;

   typedef float _height_stdev_type;
  _height_stdev_type height_stdev;

   typedef float _north_velocity_stdev_type;
  _north_velocity_stdev_type north_velocity_stdev;

   typedef float _east_velocity_stdev_type;
  _east_velocity_stdev_type east_velocity_stdev;

   typedef float _up_velocity_stdev_type;
  _up_velocity_stdev_type up_velocity_stdev;

   typedef float _roll_stdev_type;
  _roll_stdev_type roll_stdev;

   typedef float _pitch_stdev_type;
  _pitch_stdev_type pitch_stdev;

   typedef float _azimuth_stdev_type;
  _azimuth_stdev_type azimuth_stdev;

   typedef  ::novatel_oem7_msgs::INSExtendedSolutionStatus_<ContainerAllocator>  _ext_sol_status_type;
  _ext_sol_status_type ext_sol_status;

   typedef uint16_t _time_since_last_update_type;
  _time_since_last_update_type time_since_last_update;

   typedef uint16_t _reserved1_type;
  _reserved1_type reserved1;

   typedef uint32_t _reserved2_type;
  _reserved2_type reserved2;

   typedef uint32_t _reserved3_type;
  _reserved3_type reserved3;





  typedef boost::shared_ptr< ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator> const> ConstPtr;

}; // struct INSSTDEV_

typedef ::novatel_oem7_msgs::INSSTDEV_<std::allocator<void> > INSSTDEV;

typedef boost::shared_ptr< ::novatel_oem7_msgs::INSSTDEV > INSSTDEVPtr;
typedef boost::shared_ptr< ::novatel_oem7_msgs::INSSTDEV const> INSSTDEVConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator1> & lhs, const ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.nov_header == rhs.nov_header &&
    lhs.latitude_stdev == rhs.latitude_stdev &&
    lhs.longitude_stdev == rhs.longitude_stdev &&
    lhs.height_stdev == rhs.height_stdev &&
    lhs.north_velocity_stdev == rhs.north_velocity_stdev &&
    lhs.east_velocity_stdev == rhs.east_velocity_stdev &&
    lhs.up_velocity_stdev == rhs.up_velocity_stdev &&
    lhs.roll_stdev == rhs.roll_stdev &&
    lhs.pitch_stdev == rhs.pitch_stdev &&
    lhs.azimuth_stdev == rhs.azimuth_stdev &&
    lhs.ext_sol_status == rhs.ext_sol_status &&
    lhs.time_since_last_update == rhs.time_since_last_update &&
    lhs.reserved1 == rhs.reserved1 &&
    lhs.reserved2 == rhs.reserved2 &&
    lhs.reserved3 == rhs.reserved3;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator1> & lhs, const ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace novatel_oem7_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator> >
{
  static const char* value()
  {
    return "851f9e9652dfa8bbffe295e9951a3101";
  }

  static const char* value(const ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x851f9e9652dfa8bbULL;
  static const uint64_t static_value2 = 0xffe295e9951a3101ULL;
};

template<class ContainerAllocator>
struct DataType< ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator> >
{
  static const char* value()
  {
    return "novatel_oem7_msgs/INSSTDEV";
  }

  static const char* value(const ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header                      header\n"
"Oem7Header                  nov_header\n"
"float32                     latitude_stdev\n"
"float32                     longitude_stdev  \n"
"float32                     height_stdev\n"
"float32                     north_velocity_stdev\n"
"float32                     east_velocity_stdev\n"
"float32                     up_velocity_stdev\n"
"float32                     roll_stdev\n"
"float32                     pitch_stdev\n"
"float32                     azimuth_stdev\n"
"INSExtendedSolutionStatus   ext_sol_status\n"
"uint16                      time_since_last_update\n"
"uint16                      reserved1\n"
"uint32                      reserved2\n"
"uint32                      reserved3\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
"\n"
"================================================================================\n"
"MSG: novatel_oem7_msgs/Oem7Header\n"
"uint16 OEM7MSGTYPE_LOG =  0\n"
"\n"
"\n"
"string message_name\n"
"uint16 message_id\n"
"uint8  message_type\n"
"uint32 sequence_number\n"
"uint8  time_status\n"
"uint16 gps_week_number\n"
"uint32 gps_week_milliseconds\n"
"\n"
"\n"
"================================================================================\n"
"MSG: novatel_oem7_msgs/INSExtendedSolutionStatus\n"
"\n"
"uint32 POSITION_UPDATE              = 1             # 0x00000001\n"
"uint32 PHASE_UPDATE                 = 2             # 0x00000002\n"
"uint32 ZERO_VELOCITY_UPDATE         = 4             # 0x00000004\n"
"uint32 WHEEL_SEONSOR_UPDATE         = 8             # 0x00000008\n"
"uint32 ALIGN_UPDATE                 = 16            # 0x00000010\n"
"uint32 EXTERNAL_POSITION_UPDATE     = 32            # 0x00000020\n"
"uint32 INS_SOLUTIN_CONVERGENCE_FLAG = 64            # 0x00000040\n"
"uint32 DOPPLER_UPDATE               = 128           # 0x00000080\n"
"uint32 PSEUDORANGE_UPDATE           = 256           # 0x00000100\n"
"uint32 VELOCITY_UPDATE              = 512           # 0x00000200\n"
"uint32 RESERVED_1                   = 1024          # 0x00000400\n"
"uint32 DEAD_RECONING_UPDATE         = 2048          # 0x00000800\n"
"uint32 PHASE_WIND_UP_UPDATE         = 4096          # 0x00001000\n"
"uint32 COURSE_OVER_GROUND_UPDATE    = 8192          # 0x00002000\n"
"uint32 EXTERNAL_VELOCITY_UPDATE     = 16384         # 0x00004000\n"
"uint32 EXTERNAL_ATTITUDE_UPDATE     = 32768         # 0x00008000\n"
"uint32 EXTERNAL_HEADING_UPDATE      = 65535         # 0x00010000\n"
"uint32 EXTERNAL_HEIGHT_UPDATE       = 131072        # 0x00020000\n"
"uint32 RESERVED_2                   = 262144        # 0x00040000\n"
"uint32 RESERVED_3                   = 524288        # 0x00080000\n"
"uint32 ROVER_POSITION_UPDATE        = 1048576       # 0x00100000\n"
"uint32 ROVER_POSITION_UPDATE_TYPE   = 2097152       # 0x00200000\n"
"\n"
"uint32 RESERVED_4                   = 4194304       # 0x00400000\n"
"uint32 RESERVED_5                   = 8388608       # 0x00800000\n"
"uint32 TURN_ON_BIASES_ESTIMATED     = 16777216      # 0x01000000\n"
"uint32 ALIGNMENT_DIRECTION_VERIFIED = 33554432      # 0x02000000\n"
"uint32 ALIGNMENT_INDICATION_1       = 67108864      # 0x04000000\n"
"uint32 ALIGNMENT_INDICATION_2       = 134217728     # 0x08000000\n"
"uint32 ALIGNMENT_INDICATION_3       = 268435456     # 0x10000000\n"
"uint32 NVM_SEED_INDICATION_1        = 538870912     # 0x20000000\n"
"uint32 NVM_SEED_INDICATION_2        = 1073741824    # 0x40000000\n"
"uint32 NVM_SEED_INDICATION_3        = 2147483648    # 0x80000000\n"
"\n"
"\n"
"\n"
"# Alignment indication\n"
"uint32 ALIGNMENT_INCOMPLETE_ALIGNMENT = 0\n"
"uint32 ALIGNMENT_STATIC               = 1\n"
"uint32 ALIGNMENT_KINETMATIC           = 2\n"
"uint32 ALIGNMENT_DUAL_ANTENNA         = 3\n"
"uint32 ALIGNMENT_USER_COMMAND         = 4\n"
"uint32 ALIGNMENT_NVM_SEED             = 5\n"
"\n"
"# NVM Seed Indication\n"
"uint32 NVM_SEED_INACTIVE                          = 0\n"
"uint32 NVM_SEED_STORED_INVALID                    = 1\n"
"uint32 NVM_SEED_PENDING_VALIDATION                = 2\n"
"uint32 NVM_SEED_INJECTED                          = 4\n"
"uint32 NVM_SEEED_DATA_IGNORED                     = 5\n"
"uint32 NVM_SEED_ERROR_MODEL_DATA_INJECTED         = 6\n"
"\n"
"\n"
"\n"
"uint32 status\n"
;
  }

  static const char* value(const ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.nov_header);
      stream.next(m.latitude_stdev);
      stream.next(m.longitude_stdev);
      stream.next(m.height_stdev);
      stream.next(m.north_velocity_stdev);
      stream.next(m.east_velocity_stdev);
      stream.next(m.up_velocity_stdev);
      stream.next(m.roll_stdev);
      stream.next(m.pitch_stdev);
      stream.next(m.azimuth_stdev);
      stream.next(m.ext_sol_status);
      stream.next(m.time_since_last_update);
      stream.next(m.reserved1);
      stream.next(m.reserved2);
      stream.next(m.reserved3);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct INSSTDEV_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::novatel_oem7_msgs::INSSTDEV_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "nov_header: ";
    s << std::endl;
    Printer< ::novatel_oem7_msgs::Oem7Header_<ContainerAllocator> >::stream(s, indent + "  ", v.nov_header);
    s << indent << "latitude_stdev: ";
    Printer<float>::stream(s, indent + "  ", v.latitude_stdev);
    s << indent << "longitude_stdev: ";
    Printer<float>::stream(s, indent + "  ", v.longitude_stdev);
    s << indent << "height_stdev: ";
    Printer<float>::stream(s, indent + "  ", v.height_stdev);
    s << indent << "north_velocity_stdev: ";
    Printer<float>::stream(s, indent + "  ", v.north_velocity_stdev);
    s << indent << "east_velocity_stdev: ";
    Printer<float>::stream(s, indent + "  ", v.east_velocity_stdev);
    s << indent << "up_velocity_stdev: ";
    Printer<float>::stream(s, indent + "  ", v.up_velocity_stdev);
    s << indent << "roll_stdev: ";
    Printer<float>::stream(s, indent + "  ", v.roll_stdev);
    s << indent << "pitch_stdev: ";
    Printer<float>::stream(s, indent + "  ", v.pitch_stdev);
    s << indent << "azimuth_stdev: ";
    Printer<float>::stream(s, indent + "  ", v.azimuth_stdev);
    s << indent << "ext_sol_status: ";
    s << std::endl;
    Printer< ::novatel_oem7_msgs::INSExtendedSolutionStatus_<ContainerAllocator> >::stream(s, indent + "  ", v.ext_sol_status);
    s << indent << "time_since_last_update: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.time_since_last_update);
    s << indent << "reserved1: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.reserved1);
    s << indent << "reserved2: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved2);
    s << indent << "reserved3: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.reserved3);
  }
};

} // namespace message_operations
} // namespace ros

#endif // NOVATEL_OEM7_MSGS_MESSAGE_INSSTDEV_H
